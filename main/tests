import unittest
import sys
import os
import time

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import ElementClickInterceptedException, NoSuchElementException
from utils.driver_factory import get_driver
import config

# Placeholder: Import AccountSectionPage when available
# from pages.account_section_page import AccountSectionPage

class TestGuestUserLoginButton(unittest.TestCase):

    def setUp(self):
        self.driver = get_driver()
        self.driver.get(config.BASE_URL)
        self.wait = WebDriverWait(self.driver, 10)
        # Placeholder: Initialize AccountSectionPage when available
        # self.account_section = AccountSectionPage(self.driver)

    def tearDown(self):
        self.driver.quit()

    def go_to_account_section(self):
        """
        Helper to navigate to the account section.
        Replace locator and navigation logic with actual implementation.
        """
        # Placeholder: Implement navigation to account section
        # self.account_section.open()
        # Example navigation (replace with actual):
        try:
            account_menu = self.wait.until(EC.element_to_be_clickable((By.ID, "account-menu")))
            account_menu.click()
        except Exception:
            # Placeholder: Implement fallback navigation if needed
            pass

    def get_login_button(self):
        """
        Helper to get the Login button element.
        Replace locator with actual implementation.
        """
        # Placeholder: Replace with actual locator for Login button in account section
        try:
            login_btn = self.wait.until(EC.presence_of_element_located((By.XPATH, "//button[text()='Login']")))
            return login_btn
        except Exception:
            return None

    def test_login_button_visible_to_guest(self):
        """
        TC01: Verify Login button is visible in account section for guest users
        Preconditions: User is not logged in
        Steps:
          1. Navigate to app
          2. Go to account section
        Expected Result: Login button is visible and accessible
        """
        # Step 1: Navigate to app (already done in setUp)
        # Step 2: Go to account section
        self.go_to_account_section()

        # Step 3: Check Login button visibility
        login_btn = self.get_login_button()
        self.assertIsNotNone(login_btn, "Login button should be visible for guest users")
        self.assertTrue(login_btn.is_displayed(), "Login button should be displayed")
        self.assertTrue(login_btn.is_enabled(), "Login button should be enabled")

    def test_login_button_hidden_for_authenticated(self):
        """
        TC02: Ensure Login button is not visible for logged-in users
        Preconditions: User is logged in
        Steps:
          1. Log in
          2. Go to account section
        Expected Result: Login button is not visible
        """
        # Step 1: Log in
        # Placeholder: Implement login using LoginPage when available
        # from pages.login_page import LoginPage
        # login_page = LoginPage(self.driver)
        # login_page.login(config.USERNAME, config.PASSWORD)
        # For now, simulate login by navigating to login page and submitting credentials
        try:
            login_link = self.wait.until(EC.element_to_be_clickable((By.LINK_TEXT, "Login")))
            login_link.click()
            email_field = self.wait.until(EC.presence_of_element_located((By.XPATH, "//input[@id='login-email']")))
            email_field.send_keys(config.USERNAME)
            password_field = self.driver.find_element(By.XPATH, "//input[@id='login-input-password']")
            password_field.send_keys(config.PASSWORD)
            login_btn = self.driver.find_element(By.XPATH, "//button[text()='LOG IN']")
            try:
                login_btn.click()
            except ElementClickInterceptedException:
                self.driver.execute_script("arguments[0].click();", login_btn)
            # Wait for login to complete (replace with actual post-login condition)
            self.wait.until(EC.presence_of_element_located((By.ID, "account-menu")))
        except Exception:
            # Placeholder: Implement robust login logic
            pass

        # Step 2: Go to account section
        self.go_to_account_section()

        # Step 3: Check Login button is not visible
        login_btn = self.get_login_button()
        self.assertTrue(login_btn is None or not login_btn.is_displayed(), "Login button should NOT be visible for authenticated users")

    def test_login_button_keyboard_accessibility(self):
        """
        TC03: Verify Login button is focusable and clickable via keyboard
        Preconditions: User is not logged in
        Steps:
          1. Navigate to app
          2. Go to account section
          3. Tab to Login button
          4. Press Enter
        Expected Result: Login button is focused and can be activated
        """
        self.go_to_account_section()
        login_btn = self.get_login_button()
        self.assertIsNotNone(login_btn, "Login button should be present for keyboard accessibility test")

        # Step 3: Tab to Login button
        # Focus on body and send TAB until Login button is focused
        self.driver.find_element(By.TAG_NAME, "body").click()
        found = False
        for _ in range(10):  # Try up to 10 tabs
            self.driver.switch_to.active_element.send_keys(Keys.TAB)
            active = self.driver.switch_to.active_element
            if active == login_btn:
                found = True
                break
            # Optionally check by attribute
            if active.get_attribute("innerText") == "Login":
                found = True
                break
        self.assertTrue(found, "Login button should be focusable via keyboard")

        # Step 4: Press Enter to activate
        active = self.driver.switch_to.active_element
        active.send_keys(Keys.ENTER)
        # Placeholder: Validate activation (e.g., navigation or modal)
        # self.assertTrue(self.driver.current_url.endswith("/login"), "Should navigate to login page on Enter")
        # Placeholder: Implement post-activation validation

    def test_login_button_navigates_to_login_page(self):
        """
        TC04: Ensure clicking Login button redirects to login page
        Preconditions: User is not logged in
        Steps:
          1. Navigate to app
          2. Go to account section
          3. Click Login button
        Expected Result: User is redirected to login page
        """
        self.go_to_account_section()
        login_btn = self.get_login_button()
        self.assertIsNotNone(login_btn, "Login button should be present for navigation test")
        try:
            login_btn.click()
        except ElementClickInterceptedException:
            self.driver.execute_script("arguments[0].click();", login_btn)
        # Wait for navigation to login page
        self.wait.until(EC.presence_of_element_located((By.XPATH, "//input[@id='login-email']")))
        self.assertIn("/login", self.driver.current_url, "Should be redirected to login page after clicking Login button")

    def test_login_button_label_is_correct(self):
        """
        TC05: Verify Login button label reads 'Login'
        Preconditions: User is not logged in
        Steps:
          1. Navigate to account section
        Expected Result: Button label is 'Login'
        """
        self.go_to_account_section()
        login_btn = self.get_login_button()
        self.assertIsNotNone(login_btn, "Login button should be present for label test")
        self.assertEqual(login_btn.text.strip(), "Login", "Login button label should be 'Login'")

    def test_login_button_not_duplicated_on_error(self):
        """
        TC06: Ensure Login button does not appear multiple times if account section fails
        Preconditions: Simulate account section load failure
        Steps:
          1. Cause account section to fail loading (e.g., network error)
        Expected Result: Login button is not duplicated or misplaced
        """
        # Placeholder: Simulate account section load failure (e.g., network error)
        # This may require mocking network or using browser devtools protocol
        # For now, check for duplicates in normal state
        self.go_to_account_section()
        login_buttons = self.driver.find_elements(By.XPATH, "//button[text()='Login']")
        self.assertLessEqual(len(login_buttons), 1, "Login button should not be duplicated in account section")
        # Placeholder: Implement actual error simulation and validation

if __name__ == "__main__":
    unittest.main()
